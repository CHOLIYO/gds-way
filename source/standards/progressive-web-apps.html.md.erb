---
title: How to develop Progressive Web Apps (PWA)
last_reviewed_on: 2018-10-31
review_in: 6 months
---

# <%= current_page.data.title %>

Progressive Web Apps (PWA) allow you to create native app experiences using web technologies and delivered using web infrastructure. With PWA you maintain and release features as part of your standard service, you do not need to develop and support them separately.

PWA are commonly supported by modern devices, [79% of the UK population](https://caniuse.com/#feat=serviceworkers) can now benefit from PWA core functionality.

Read more about [what makes something a PWA](https://infrequently.org/2016/09/what-exactly-makes-something-a-progressive-web-app/).

## PWA core technology

PWA core technology includes, service workers, web app manifest, application shell architecture, Fetch API and IndexedDB.

### Service workers

[Service workers](https://codeburst.io/an-introduction-to-service-workers-in-javascript-27d6376460c2) are programmable network proxies written in JavaScript and running separately from the main browser thread.

Using service workers mean your browser improves your site or application performance by caching essential assets. By working [offline-first](https://codelabs.developers.google.com/codelabs/workbox-indexeddb/index.html?index=..%2F..%2Findex#0) with a service worker your browser delivers content to your users when they are offline.

Service workers require HTTPS. Because service workers intercept and modify network requests, a [man-in-the-middle attack](https://us.norton.com/internetsecurity-wifi-what-is-a-man-in-the-middle-attack.html) would be serious. Using HTTPS removes this potential attack vector.

Your browser acts as a gateway to more advanced features allowing PWA to act like native applications using:

#### Background Sync API

[Background Sync API](https://developers.google.com/web/updates/2015/12/background-sync) - defers messaging until users are on stable connections.

#### Notifications API

[Notifications API](https://developers.google.com/web/fundamentals/push-notifications/display-a-notification) - displays notifications using a device’s messaging system.

#### Channel Messaging API

[Channel Messaging API](https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API) - allows service workers and web workers to communicate with each other and the host application.

#### Push API

[Push API](https://www.w3.org/TR/push-api/) - enables apps to subscribe to push messages or trigger periodic updates of an app’s local state.

### Web app manifest

[Web App Manifest](https://www.w3.org/TR/appmanifest/) is a JSON file that tells your browser about your application and how it behaves when installed. When users install your application, their browser looks at the web app manifest for the application’s settings including its post installation behaviour.

Typical manifest files include information about (required fields marked with an *):

- `short_name`*
- `name`*
- `icons`*
- `start_url`*
- `background_color`
- `display`
- `scope`
- `theme_color`

Adding a single meta tag to the document head tells the browser a manifest file exists:

`<link rel="manifest" href="/manifest.json">`

This automatically generates an application splash screen from the `name`, `background_colour`, and `icons` properties.

### Application shell architecture

Application shell (app shell) is [the minimal view for your application](https://developers.google.com/web/updates/2015/11/app-shell). Once the app shell caches on a device it does not need to load over the network again. Only the main application content loads over the network.

App shell creates native-like interactions that instantly load even offline, saving users’ data by only downloading apps’ minimum necessary content.

### Fetch API

Fetch API is a simple interface for fetching resources. It replaces [XMLHttpRequest](https://xhr.spec.whatwg.org/) which often needed additional logic to handle some types of responses, like handling redirects.

For example, requests from a fetch call return a promise that resolves to a response object. The response passes to a `.then` method where it uses the response. Should the request fail it passes to a `.catch` method for error handling.

Read [Introduction to fetch()](https://developers.google.com/web/updates/2015/03/introduction-to-fetch) and [JavaScript Promises: an Introduction](https://developers.google.com/web/fundamentals/primers/promises) to find out more.

### IndexedDB

[IndexedDB](https://dev.opera.com/articles/introduction-to-indexeddb/) is a large-scale, [NoSQL](https://www.mongodb.com/nosql-explained) system for storing any data needed by an app in a user’s browser. Each IndexedDB database is unique to its origin, usually a site domain or subdomain, meaning other domains cannot access the data.

With IndexedDB [data storage limits](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Browser_storage_limits_and_eviction_criteria) are quite large if they exist at all, because some browsers handle [storage limit and data eviction very differently](https://developers.google.com/web/ilt/pwa/working-with-indexeddb#resources).

## PWA core functionality

With PWA core technology you create web apps that mimic functionality only associated in the past with native applications.

PWA core functionality includes:

- offline browsing
- asset precaching
- background sync
- push notifications
- add to homescreen

### Offline browsing

With PWA you cache assets from your website for later use, even when users are offline. For example, a service worker intercepts requests for assets and retrieves them from the browser cache instead of the network.

You could also deliver a custom offline page for your app. If you use asset precaching it’s possible to cache some, if not all of your website for offline viewing.

### Asset precaching

 Service workers [precache a list of assets](https://developers.google.com/web/tools/workbox/modules/workbox-precaching) for later use. This happens on the service workers [install event](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Install_and_activate_populating_your_cache).

 For example, if you’re using a [cache first strategy](https://developers.google.com/web/tools/workbox/modules/workbox-strategies#cache_first_cache_falling_back_to_network), when a webpage uses these critical assets, the service worker intercepts the request delivering the webpage from the browser cache instead of the network.

You could also expand precaching to include other pages, or potentially cache your entire website for offline viewing. If you cache your entire website consider its total size first.

For example, precache automatically requests all assets in the background without your users' knowledge or control. If your users have an expensive, data limited mobile plan, they should not have to download unneeded data. Because browser storage space is finite, storing too much data will result in a browser error.

### Background sync API

[Background sync API](https://developers.google.com/web/updates/2015/12/background-sync) allows you to suspend an action until a user has a stable network connection network connection, making sure your users data is actually sent.

This means users can send messages offline. Messages are stored in the background and transmitted once the browser establishes a network connection.

### Push notifications

[Push notifications](https://medium.com/@derek_dyer/progressive-web-applications-push-notifications-d7cfb42f30c3) use a device’s native notification method. Notifications are either triggered by an application or pushed from a server. This happens even when the app is offline.

Push notifications use:

- [Push API](https://developer.mozilla.org/en-US/docs/Web/API/Push_API) - allowing your app to handle pushed messages from a server
- [Notifications API](https://notifications.spec.whatwg.org/) - working with user’s devices to show messages
- [Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) - controlling the flow through push and notification APIs

Limit the number of notifications sent to your users but do not switch them all off. If you switch off all notifications you’ll lose important user engagement.

### Add to Homescreen

[Add to Homescreen](https://developers.google.com/web/fundamentals/app-install-banners/) (sometimes called the web app install prompt) allows users to install a PWA on their mobile or desktop. Once added to the homescreen an app imitates native app functionality.

Add to Homescreen requires the web app manifest file.

## Case study - Workbox

GDS recommends [Workbox](https://developers.google.com/web/tools/workbox/) to incorporate PWA into your service, using the Workbox library to add offline support to its web apps.

Workbox is an [open source service worker library](https://github.com/GoogleChrome/workbox) created by Google, it’s well tested and [used by thousands of websites](https://developers.google.com/web/showcase/). If you write your service worker without any abstraction libraries you could include inferior code in your design.

Using Workbox means you:

- add offline capabilities to your website or web application
- remove the need to create boilerplate code for each service worker
- benefit from a [comprehensive set of documentation](https://developers.google.com/web/tools/workbox/guides/get-started)

Workbox comes with [built-in functionally](https://developers.google.com/web/tools/workbox/reference-docs/latest/) including:

- asset precaching
- runtime caching
- caching strategies
- request routing
- background sync
- offline Google Analytics tracking
- comprehensive debugging

You’ll need to write some code to define what this functionality controls, but it’s much simpler than writing a service worker from scratch.

The GDS Forum reviews the recommendation to use Workbox every six months to make sure it’s still the best choice for GDS teams.

### Build process integration

Integrate Workbox into your current build process without writing any code using three node modules, Workbox Command Line Interface (CLI), workbox-build and Workbox webpack Plugins.

[Workbox Command Line Interface (CLI)](https://developers.google.com/web/tools/workbox/modules/workbox-cli) - use CLI if you’re new to Node and frontend build tools. With the CLI you integrate Workbox into projects that do not rely on the Node toolchain for their frontend development, like Ruby on Rails.

[Workbox-build](https://developers.google.com/web/tools/workbox/modules/workbox-build) - use workbox-build if you’re familiar with languages like Node or Gulp to generate your service workers.

[Workbox webpack Plugins](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin) - if you use webpack in your build pipeline, Workbox provides you with a plugin to generate your service worker with three class.

| Workbox-webpack-plugin classes  |  Description |
|---|---|
|  [generateSW()](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-webpack-plugin-GenerateSW) |  Automatically generates most of the service worker, controls precaching and includes customisation options, writes the service worker code to disk |
|  generateSWString() |  Identical to `generateSW()` but returns as a string Useful if you need to manually change the service worker configuration it writes to disk|
|  [injectManifest()](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-webpack-plugin-InjectManifest)  |   Allows complete control of service worker setup, uses asset precaching, when generating the service worker, an automatically generated list of files replaces the precache placeholder, recommended if you need low level control over service worker functionality|
|getManifest()| Generates the file manifest, but leaves the injection into the service worker to the developer, useful if you need to use the manifest from an existing service worker|

### Example service worker code

The code example shows how to include Workbox in your build pipeline to generate a service worker. The example uses `injectManifest()`, allowing more control over the service worker as well as precache functionality.

Read the Workbox documentation and see more examples in the [Workbox Get Started guide](https://developers.google.com/web/tools/workbox/guides/get-started).

Service Worker example code:

```js
/**
service-worker-example-src.js
You can use this example service worker file with injectManifest()
**/

/**
Import the Workbox library from the Google CDN. It’s possible to serve this locally if you want to remove the dependency on Google. For more information read the Workbox documentation.

**/
importScripts('https://storage.googleapis.com/workbox-cdn/releases/3.3.1/workbox-sw.js');

workbox.setConfig({
  // set the local path is not using Google CDN
  //modulePathPrefix: '/directory/to/workbox/'

  // By default, workbox-sw will use the debug build for sites on localhost,
  // but for any other origin it’ll use the production build. Force by setting to true.
  // debug: true
});
// Force verbose logging even for the production
// workbox.core.setLogLevel(workbox.core.LOG_LEVELS.debug)

// Cache settings
workbox.core.setCacheNameDetails({
  // set the default cache name prefix. each domain should be unique to stop clashes
  // this is used for runtime and precaching only
  prefix: 'sample-cache'
});

// Example of cachefirst strategy for the JavaScript
workbox.routing.registerRoute(
  // match only with assets on this domain
  new RegExp('https://sample.testdomain.com/.*\.js$'),
  workbox.strategies.cacheFirst({
    cacheName: 'sample-js-cache'
  })
);

// Example of using a network first strategy for CSS files as well as setting custom
// expiration settings
workbox.routing.registerRoute(
  // match only with assets on this domain
  new RegExp('https://sample.testdomain.com/.*\.css$'),
  workbox.strategies.networkFirst({
    cacheName: 'sample-css-cache',
    plugins: [
      new workbox.expiration.Plugin({
        // 28 days cache before expiration
        maxAgeSeconds: 24 * 60 * 60 * 28,
        // Opt-in to automatic cleanup whenever a quota errors occurs anywhere in Workbox
        purgeOnQuotaError: true // Opt-in to automatic cleanup.
      })
    ]
  })
);

// Using networkOnly means the assets will only ever come from the network,
// the service worker never caches them
workbox.routing.registerRoute(
  // match only with assets on this domain
  new RegExp('https://sample.testdomain.com/.*\.woff2$'),
  workbox.strategies.networkOnly({
    cacheName: 'sample-font-cache'
  })
);

// If Workbox setup defines any rules this is where it injects them
workbox.precaching.precacheAndRoute([]);

// skip the 'worker in waiting' phase and activate immediately
workbox.skipWaiting();
// claim any clients that match the worker scope immediately. requests on these pages will
// now go via the service worker.
workbox.clientsClaim();
```
Use the following module with Node.js to generate a service worker based on the Service Worker example code:

```js
/**
build-service-worker.js
Custom node module used to generate the service worker. Include this in your build pipeline (node) like this:

const generateServiceWorker = require('build-service-worker');
// Now generate the service worker (make sure this runs after it generates all files)
generateServiceWorker.init();
**/

'use strict'
const { injectManifest } = require('workbox-build')

module.exports = {
  generate: function () {
    injectManifest({
      swSrc: 'lib/service-worker-example-src.js',
      swDest: 'dist/service-worker-example.js',
      globDirectory: 'dist/',
      globPatterns: ['**/*.{js,css,html}']
    })
    // notify console of generation data
    .then(({ count, size }) => {
      console.info(`Service worker generation complete which will precache ${count} files, totaling ${(size / 1024 / 1024).toFixed(2)} megabytes.`)

      return { count, size }
    })
    // if there are errors, what happened
    .catch((error) => {
      console.error('Service worker generation failed: ' + error)
    })
  },
  init: function () {
    // generate the service worker
    this.generate()
  }
}
```

All HTML files on the domain include the following code. The code checks for API support then registers the service worker for use.

```html
<body>
  <!-- ..... -->
  <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          // Scope will be restricted to the path where the service-worker-example.js file is located
          navigator.serviceWorker.register('/service-worker-example.js', {scope: '/'}).then(registration => {
            console.log('Service Worker registered: ', registration)
          }).catch(registrationError => {
            console.log('Service Worker registration failed: ', registrationError)
          })
        })
      }
  </script>
</body>
```
